using Microsoft.VisualBasic.FileIO;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Text;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace NEA_Graphing_with_Bitmaps_in_Core
{
    public partial class Form1 : Form
    {
        private Bitmap canvas; //instantiates a persistent bitmap.
        private Graphics canvasGraphics; //object that does the drawing.

        public Form1()
        {
            InitializeComponent();

            this.DoubleBuffered = true; //keep being reading that this reduces drawn line flicker.

            InitializeCanvas(); //calls method that creates the bitmap and its graphics object after disposing of any existing ones.

            RedrawGraph();
        }

        private void InitializeCanvas()
        {
            canvasGraphics?.Dispose();
            canvas?.Dispose(); //the canvas and its graphics cannot be disposed of in one go; they have to be disposed separately.
            canvas = new Bitmap(this.ClientSize.Width, this.ClientSize.Height); //ensures the bitmap is the size of the entire client area (SUBJECT TO CHANGE).
            canvasGraphics = Graphics.FromImage(canvas); //creates bitmap's graphics object.
            canvasGraphics.Clear(Color.White); //sets the bitmap's background to white.
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            base.OnPaint(e);

            if (canvas == null)
                return;

            e.Graphics.DrawImageUnscaled(canvas, 0, 0); //places bitmap on the form, aligned with the top left (coordinate point (0,0)).
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            var records = LoadCSVFile("TB_burden_countries_2026-01-12.csv");

            var distinctRegions = records
                .Select(r => r.Region)
                .Distinct()
                .OrderBy(r => r)
                .ToList();
            MessageBox.Show(string.Join(", ", distinctRegions));
            //the little paragraph directly above this message is temporary

            var regionalData = GroupByRegion(records);

            this.TBDataByRegion = regionalData;

            MessageBox.Show($"Records loaded: {records.Count}\nRegions after grouping: {regionalData.Count}"); //keep this in so you can explain why it says there are 5 regions when you've provided 6 region codes (WHO datasets don't always include data for each region, and the Eastern Mediterranean Region was lacking data for some years).

            RedrawGraph();

        }

        protected override void OnResize(EventArgs e) //for when people minimise and maximise their window.
        {
            base.OnResize(e);

            if (canvas == null) //kept getting a null unhandled exception at g.DrawImageUnscaled(canvas, 0, 0) a little later on in the code so I added this here.
                return;

            if (this.ClientSize.Width <= 0 || this.ClientSize.Height <= 0) //ignore if the window is ever minimised.
                return;

            Bitmap newCanvas = new Bitmap(this.ClientSize.Width, this.ClientSize.Height); //bitmap resized to match ClientSize area.

            using (Graphics g = Graphics.FromImage(newCanvas)) //temp graphics object.
            {
                g.Clear(Color.White); //reset background upon resizing.
                g.DrawImageUnscaled(canvas, 0, 0); //copy the graph from the previous bitmap onto this new, resized bitmap.
            }

            canvasGraphics.Dispose();
            canvas.Dispose();
            canvas = newCanvas;
            canvasGraphics = Graphics.FromImage(canvas); //new bitmap needs new graphics object.

            this.Invalidate(); //force the form to paint the graph again 
        }

        private void RedrawGraph()
        {
            if (canvasGraphics == null)
                return;

            if (TBDataByRegion == null)
                return;

            canvasGraphics.Clear(Color.White);

            Rectangle plotArea = new Rectangle(80, 40, (canvas.Width - 120), (canvas.Height - 100));

            GetAutoScaleBounds(out int minYear, out int maxYear, out double minIncidence, out double maxIncidence);

            DrawAxes(plotArea);
            DrawAxesScales(plotArea, 5, (int)minIncidence, (int)maxIncidence, minYear, maxYear);
            DrawAxesTitles(plotArea);
            PlotRegionData(plotArea, minYear, maxYear, minIncidence, maxIncidence);

            Invalidate();
        }

        private void DrawAxes(Rectangle plotArea) //draws axes before plotting data
        {
            using (Pen axisPen = new Pen(Color.Black, 2))
            {
                canvasGraphics.DrawLine(axisPen, plotArea.Left, plotArea.Bottom, plotArea.Right, plotArea.Bottom); //this paints the x-axis.
                canvasGraphics.DrawLine(axisPen, plotArea.Left, plotArea.Top, plotArea.Left, plotArea.Bottom); //this paints the y-axis
            }
        }

        private void DrawAxesScales(Rectangle plotArea, int tickCount, int minimumValue, int maximumValue, int startYear, int endYear)
        {
            using (Font labelFont = new Font("Segoe UI", 10))
            using (Pen tickPen = new Pen(Color.Black, 2))
            using (Brush textBrush = new SolidBrush(Color.Black))
            {
                double incidenceStep = (maximumValue - minimumValue) / tickCount;

                for (int i = 0; i <= tickCount; i++) //increments i from 0 upwards while it is less than or equal to 'tickCount'
                {
                    double value = minimumValue + incidenceStep * i;
                    float ratio = (float)((value - minimumValue) / (maximumValue - minimumValue));
                    int y = plotArea.Bottom - (int)(ratio * plotArea.Height);

                    canvasGraphics.DrawLine(tickPen, (plotArea.Left - 5), y, plotArea.Left, y);

                    string label = ((int)value).ToString();

                    SizeF size = canvasGraphics.MeasureString(label, labelFont);

                    canvasGraphics.DrawString(label, labelFont, textBrush, plotArea.Left - size.Width - 8, y - size.Height / 2);
                }

                int yearStep = (endYear - startYear) / tickCount;

                for (int year = startYear; year <= endYear; year += yearStep)
                {
                    float ratio = (float)(year - startYear) / (endYear - startYear);
                    int x = plotArea.Left + (int)(ratio * plotArea.Width);

                    canvasGraphics.DrawLine(tickPen, x, plotArea.Bottom, x, (plotArea.Bottom + 5));

                    string label = year.ToString();

                    SizeF size = canvasGraphics.MeasureString(label, labelFont);

                    canvasGraphics.DrawString(label, labelFont, textBrush, x - size.Width / 2, plotArea.Bottom + 8); //fix this so values align with x-axis ticks
                }
            }
        }

        private void DrawAxesTitles(Rectangle plotArea)
        {
            using (Font titleFont = new Font("Segoe UI", 10, FontStyle.Bold))
            using (Brush brush = new SolidBrush(Color.Black))
            {
                float xAxisCentre = plotArea.Left + plotArea.Width / 2;

                string xAxisTitle = "Year (PLACEHOLDER)";

                SizeF xAxisSize = canvasGraphics.MeasureString(xAxisTitle, titleFont);

                canvasGraphics.DrawString(xAxisTitle, titleFont, brush, (xAxisCentre - xAxisSize.Width / 2), (plotArea.Bottom + 30));

                string yAxisTitle = "Cases per 100,000 people (PLACEHOLDER)";

                canvasGraphics.TranslateTransform(20, (plotArea.Top + plotArea.Height / 2));

                canvasGraphics.RotateTransform(-90);

                SizeF yAxisSize = canvasGraphics.MeasureString(yAxisTitle, titleFont);

                canvasGraphics.DrawString(yAxisTitle, titleFont, brush, (-yAxisSize.Width / 2), 0);

                canvasGraphics.ResetTransform();
            }
        }

        public class TBIncidenceRecord
        {
            public string Region { get; set; }
            public bool IsGlobal {  get; set; }
            public int Year { get; set; }
            public double IncidencePer100k { get; set; }
        } //constructs objects that will store TB cases per 100,000 people, the year that data was recorded in, and the WHO-designated region that data was recorded in.

        private List<TBIncidenceRecord> LoadCSVFile(string filePath) //for listing the values found in the CSV file.
        {
            var records = new List<TBIncidenceRecord>(); //a list that will store the parsed data.

            using (var parser = new TextFieldParser(filePath))
            {
                parser.SetDelimiters(","); //splits individual data items.
                parser.HasFieldsEnclosedInQuotes = true;

                string[] headers = parser.ReadFields();

                int regionIndex = Array.IndexOf(headers, "g_whoregion"); //finds the column containing region names so only specific ones (later defined) will be considered.
                int countryIndex = Array.IndexOf(headers, "country");
                int yearIndex = Array.IndexOf(headers, "year");
                int incidenceIndex = Array.IndexOf(headers, "e_inc_100k");

                while (!parser.EndOfData) //executes contents of the while loop so long as it hasn't looped to the end of the CSV file.
                {
                    string[] fields = parser.ReadFields();

                    if (fields.Length <= Math.Max(regionIndex, Math.Max(yearIndex, incidenceIndex)))
                        continue; //ensures the row has all required columns so it doesn't throw an error when parts if the CSV file is missing values or if it has empty columns.

                    if (!int.TryParse(fields[yearIndex], out int year))
                        continue; //parses the year

                    if (!double.TryParse(fields[incidenceIndex], out double incidence))
                        continue; //parses the incidence of TB per 100k

                    bool isGlobal = fields[countryIndex] == "Global";

                    records.Add(new TBIncidenceRecord
                    {
                        Region = isGlobal ? "GLOBAL" : fields[regionIndex],
                        IsGlobal = isGlobal,
                        Year = year,
                        IncidencePer100k = incidence
                    }); //creates a record that stores the necessary data for plotting.
                }
            }

            return records;
        }

        private void GetAutoScaleBounds(
            out int minYear,
            out int maxYear,
            out double minIncidence,
            out double maxIncidence)
        {
            var allRecords = TBDataByRegion.Values.SelectMany(r => r).ToList();

            minYear = (allRecords.Min(r => r.Year) / 5) * 5;
            maxYear = ((allRecords.Max(r => r.Year) + 4) / 5) * 5; //these ensure the x-axis scale looks readable (increments by the same value), hopefully no matter which disease's CSV file is input. The plotted lines also change to still accurately align with the new scales.

            minIncidence = 0; //gotta start somewhere
            maxIncidence = Math.Ceiling(allRecords.Max(r => r.IncidencePer100k) / 50) * 50; //this ensures the y-axis scale looks readable (increments by the same value), hopefully no matter which disease's CSV file is input. The plotted lines also change to still accurately align with the new scales.
        }

        private static readonly HashSet<string> TargetRegionCodes = new HashSet<string>
        {
            "AFR", "AMR", "SEAR", "EUR", "EMR", "WPR", "GLOBAL"
            //"African Region", "Region of the Americas", "South-East Asia Region", "European Region", "Eastern Mediterranean Region", "Western Pacific Region"
        }; //this actually defines what WHO-designated regions I want to plot data for.
        //unsure of why I'm actually using a HashSet, it provides a very fast lookup time, but it's not like there's many items to lookup. However, if ever graphs needed to be made for each country rather than each region, this HashSet could be updated to contain every country WHO has data for, in which case the fast lookup times would be relevant.
        
        private Dictionary<string, List<TBIncidenceRecord>> GroupByRegion(List<TBIncidenceRecord> records)
        {
            return records
                .Where(r => r.IsGlobal || TargetRegionCodes.Contains(r.Region)) //ensures we're only considering the 6 regions specified above, and the 'GLOBAL' region if it's included in the CSV file.
                .GroupBy(r => r.Region) //group the data by its region
                .ToDictionary(regionGroup => regionGroup.Key, regionGroup => regionGroup.GroupBy(r => r.Year).Select(yearGroup => new TBIncidenceRecord //adds region groups to a dictionary, where its key is the WHO region codes
                {
                    Region = regionGroup.Key, Year = yearGroup.Key, IncidencePer100k = yearGroup.Average(r => r.IncidencePer100k)
                }) //gives the arithmetic mean per 100,000 people for incidence of the disease, for a given region, for a given year.
                .OrderBy(r => r.Year) //points are plotted from left to right, consistent with the direction of the x-axis.
                .ToList()
                );
        } //groups yearly data by its relevant region

        private Dictionary<string, List<TBIncidenceRecord>> TBDataByRegion;

        private Point[] ConvertToPoints(List<TBIncidenceRecord> data, Rectangle plotArea, int minYear, int maxYear, double minValue, double maxValue)
        {
            return data.Select(d =>
            {
                float xRatio = (float)(d.Year - minYear) / (maxYear - minYear);
                xRatio = Math.Max(0f, Math.Min(1f, xRatio));
                int x = plotArea.Left + (int)(xRatio * plotArea.Width); //allows year to be mapped to pixels on the graph space.

                float yRatio = (float)((d.IncidencePer100k - minValue) / (maxValue - minValue));
                yRatio = Math.Max(0f, Math.Min(1f, yRatio));
                int y = plotArea.Bottom - (int)(yRatio * plotArea.Height); //allows incidence per 100k to be mapped to pixels on the graph space.

                return new Point(x, y); //returns a point that can actually be plotted.
            }).ToArray();
        }

        private readonly Color[] RegionColours =
        {
            Color.Red,
            Color.Green,
            Color.Blue,
            Color.Cyan,
            Color.Magenta,
            Color.Yellow,
            Color.Black
        }; //each region's data is plotted with a specific colour, legend will be added later.

        private void PlotRegionData(Rectangle plotArea, int minYear, int maxYear, double minValue, double maxValue) //RENAME THIS? this method does the plotting of actual data.
        {
            if (TBDataByRegion == null)
                return; //prevents an error thrown by the line below.

            int colourIndex = 0;

            foreach (var region in TBDataByRegion)
            {
                Point[] points = ConvertToPoints(region.Value, plotArea, minYear, maxYear, minValue, maxValue);

                if (points.Length < 2)
                    continue;

                using (Pen graphPen = new Pen(RegionColours[colourIndex % RegionColours.Length], 2)) //pen for drawing the graph itself
                {
                    canvasGraphics.DrawLines(graphPen, points); //paints lines connecting the data points provided above.
                }

                colourIndex++;
            }

            this.Invalidate(); //force the form to paint the graph again
        }
    }
} //program could display a message explaining why there are fewer than 6 regions displayed, stating that the line was omitted as the data wasn't present in the CSV file.
